type Coffee implements Food {
  id: Int!
  name: String!
  origin: String!
  price: Float!
  sugarLevel: SugarLevel!
}

scalar DateTime

type Dessert implements Food {
  calories: Float!
  id: Int!
  name: String!
  price: Float!
}

interface Food {
  id: Int!
  name: String!
  price: Float!
}

union MenuItem = Coffee | Dessert

type Mutation {
  createCoffee(name: String!, origin: String!, price: Float!, sugarLevel: SugarLevel!): Coffee!
  createDessert(calories: Float!, name: String!, price: Float!): Dessert!
  createOrder(items: [Int!]!, userId: Int!): Order!
  createUser(email: String!, name: String!): User!
  deleteMenuItem(id: Int!): MenuItem
  deleteOrder(id: Int!): Order
  deleteUser(id: Int!): User
  updateCoffee(id: Int!, name: String, origin: String, price: Float, sugarLevel: SugarLevel): Coffee
  updateDessert(calories: Float, id: Int!, name: String, price: Float): Dessert
  updateOrder(id: Int!, status: OrderStatus!): Order
  updateUser(email: String, id: Int!, name: String): User
}

type Order {
  createdAt: DateTime!
  id: Int!
  itemIds: [Int!]!
  items: [MenuItem!]
  status: OrderStatus!
  user: User
  userId: Int!
}

enum OrderStatus {
  CANCELLED
  COMPLETED
  PENDING
}

type Query {
  menu: [MenuItem!]!
  menuItem(id: Int!): MenuItem
  order(id: Int!): Order
  orders: [Order!]!
  user(id: Int!): User
  users: [User!]!
}

enum SugarLevel {
  HIGH
  LOW
  MEDIUM
  NONE
}

type User {
  email: String!
  id: Int!
  name: String!
  orders: [Order!]
}